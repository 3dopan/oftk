# 選択状態管理の改善提案

## 1. 現状の問題点

### 1.1 インデックスベースの選択管理

現在の実装では、`selected_index: Option<usize>`を使用してアイテムの選択状態を管理しています。

```rust
// app/state.rs
pub struct AppState {
    pub selected_index: Option<usize>,
    // ...
}
```

この方式は、**フラットな配列**を前提としています。

### 1.2 階層構造との不整合

再帰的ツリー表示（Task 6.3で実装）では、階層構造を持つディレクトリを扱います。

```
entries[0]  // ルートのディレクトリA
  └─ sub_items[0]  // サブディレクトリA-1
  └─ sub_items[1]  // サブディレクトリA-2
entries[1]  // ルートのディレクトリB
  └─ sub_items[0]  // サブディレクトリB-1
```

この場合、以下の問題が発生します：

1. **サブアイテムのインデックスが親のインデックスと無関係**
   - `entries`配列のインデックスと`sub_items`配列のインデックスは別々
   - `selected_index = 0`がルートのディレクトリAなのか、サブディレクトリA-1なのか判別不可

2. **選択状態が階層を跨げない**
   - ルートレベルのアイテムしか選択状態を管理できない
   - サブディレクトリをクリックしても選択状態が正しく反映されない

3. **現在の暫定対処**
   - サブディレクトリの選択状態は無視（`selected_index = None`を渡す）
   - ユーザーがサブディレクトリをクリックしても選択状態が更新されない

### 1.3 影響範囲

`selected_index`を使用しているファイル：
- `ofkt/src/ui/file_tree.rs` - ツリー表示ロジック
- `ofkt/src/app/mod.rs` - 選択状態の更新、キーボード操作
- `ofkt/src/app/state.rs` - 状態管理
- `ofkt/src/ui/history.rs` - 履歴表示（参考情報）

---

## 2. 改善提案

### 2.1 パスベースの選択管理

インデックスベースの選択管理を**パスベース**に変更します。

```rust
// app/state.rs
pub struct AppState {
    // 変更前
    // pub selected_index: Option<usize>,

    // 変更後
    pub selected_path: Option<PathBuf>,
    // ...
}
```

### 2.2 メリット

1. **階層に依存しない選択状態管理**
   - パスで一意に識別できる
   - ルートレベルでもサブレベルでも同じ方法で選択状態を管理

2. **直感的な選択管理**
   - ユーザーがクリックしたアイテムのパスを直接保存
   - パスの比較で選択状態を判定

3. **拡張性**
   - 将来的に検索結果からの選択にも対応可能
   - ブックマークやお気に入りとの統合が容易

### 2.3 デメリット

1. **既存コードへの影響範囲が大きい**
   - `selected_index`を使用している全箇所の変更が必要
   - app/mod.rs のキーボード操作ロジックの大幅な書き換え

2. **パフォーマンスへの影響**
   - インデックス比較（O(1)）からパス比較（O(n)）に変更
   - ただし、パス比較は文字列比較なので、実用上は問題ない

3. **実装コストが高い**
   - 変更箇所が多い
   - テストが必要

---

## 3. 実装計画

### 3.1 段階的な実装

一度に全てを変更するのではなく、段階的に実装します。

#### Phase 1: AppStateの変更
1. `selected_path: Option<PathBuf>`フィールドを追加
2. `selected_index`を残したまま並行運用
3. ディレクトリモードのみパスベース選択に移行

#### Phase 2: FileTreeViewの変更
1. `render_directory_tree()`のシグネチャを変更
   ```rust
   // 変更前
   pub fn render_directory_tree(
       &mut self,
       ui: &mut egui::Ui,
       entries: &[DirectoryEntry],
       expanded_dirs: &mut HashSet<PathBuf>,
       selected_index: Option<usize>,  // ← これを変更
   ) -> (Option<usize>, bool)

   // 変更後
   pub fn render_directory_tree(
       &mut self,
       ui: &mut egui::Ui,
       entries: &[DirectoryEntry],
       expanded_dirs: &mut HashSet<PathBuf>,
       selected_path: Option<&PathBuf>,  // ← パスベースに
   ) -> (Option<PathBuf>, bool)  // ← 戻り値もパスに
   ```

2. `render_tree_node()`も同様に変更

#### Phase 3: app/mod.rsの変更
1. クリックイベント処理をパスベースに変更
2. キーボード操作（↑↓）のロジックを変更
   - インデックス加算/減算ではなく、配列内でパスを検索
   - 次/前のアイテムのパスを取得

#### Phase 4: エイリアスモードの対応
1. エイリアスモードは`selected_index`を継続使用
2. 将来的にエイリアスIDベースの選択に移行を検討

#### Phase 5: クリーンアップ
1. `selected_index`フィールドを削除
2. 関連する未使用コードを削除
3. ドキュメント更新

### 3.2 実装の難易度

| タスク | 難易度 | 工数見積もり |
|--------|--------|--------------|
| AppStateの変更 | 低 | 0.5時間 |
| FileTreeViewの変更 | 中 | 1.5時間 |
| app/mod.rsのクリック処理変更 | 低 | 0.5時間 |
| app/mod.rsのキーボード操作変更 | 高 | 3時間 |
| テスト作成・実施 | 中 | 2時間 |
| **合計** | - | **7.5時間** |

---

## 4. 代替案の検討

### 4.1 案A: ハイブリッド管理（推奨しない）

`selected_index`と`selected_path`を両方維持する。

**メリット**:
- 既存コードへの影響が少ない
- 段階的な移行が可能

**デメリット**:
- 状態の同期が必要（複雑化）
- 将来的に技術的負債となる

**結論**: 推奨しない

### 4.2 案B: IDベースの管理

各エントリに一意のIDを割り当て、IDで選択状態を管理する。

```rust
pub struct DirectoryEntry {
    pub id: String,  // 一意のID
    pub name: String,
    pub path: PathBuf,
    // ...
}
```

**メリット**:
- パスよりも比較が高速
- 重複ファイル名にも対応可能

**デメリット**:
- DirectoryEntryにIDフィールドを追加する必要がある
- IDの生成ロジックが必要（UUID? ハッシュ?）
- パスベースよりも実装コストが高い

**結論**: 将来的な検討課題

### 4.3 案C: 現状維持（最小限の対応）

`selected_index`を維持し、ルートレベルのみ選択可能とする。

**メリット**:
- 実装コストがゼロ
- 既存コードへの影響がない

**デメリット**:
- サブディレクトリの選択ができない
- UXが悪い（ユーザーがクリックしても反応しない）

**結論**: ユーザーエクスペリエンスの観点から推奨しない

---

## 5. 推奨アプローチ

### 5.1 短期的な対応（現状維持）

Task 6.3の実装では、サブディレクトリの選択状態を無視することで、既存の動作を維持します。

**理由**:
1. Task 6.3の目的は「3階層以上の表示」であり、選択状態の改善は含まれない
2. 段階的な実装により、リスクを最小化
3. リリース後のフィードバックを受けてから改善を検討

### 5.2 中期的な対応（パスベース選択の実装）

ユーザーからの要望や使用状況を確認した上で、パスベース選択を実装します。

**実装タイミング**:
- Task 6.3のリリース後
- ユーザーフィードバックを受けた後
- 次のマイルストーンで優先度を判断

**実装方法**:
- 「3. 実装計画」に従って段階的に実装
- Phase 1〜5を順次実施
- 各Phaseでテストとレビューを実施

### 5.3 長期的な検討（IDベース選択）

パフォーマンスや機能拡張の必要性に応じて、IDベース選択を検討します。

---

## 6. 影響を受けるコード

### 6.1 変更が必要なファイル

1. **ofkt/src/app/state.rs**
   - `selected_index: Option<usize>` → `selected_path: Option<PathBuf>`

2. **ofkt/src/ui/file_tree.rs**
   - `render_directory_tree()`のシグネチャ変更
   - `render_tree_node()`のシグネチャ変更
   - 選択状態の判定ロジック変更

3. **ofkt/src/app/mod.rs**
   - クリックイベント処理の変更
   - キーボード操作（↑↓）のロジック変更
   - Enterキー処理の変更

### 6.2 影響を受けない（または軽微）なファイル

- `ofkt/src/ui/history.rs` - 履歴表示（参考情報として使用しているのみ）
- `ofkt/src/core/*.rs` - コアロジックは変更不要
- `ofkt/src/data/*.rs` - データモデルは変更不要

---

## 7. テスト計画

### 7.1 単体テスト
- パス比較ロジックのテスト
- 選択状態の更新テスト

### 7.2 統合テスト
- ディレクトリツリーでの選択状態テスト
- キーボード操作による選択移動テスト
- クリック操作による選択変更テスト

### 7.3 手動テスト
- 3階層以上のディレクトリでの選択動作確認
- サブディレクトリの選択が正しく反映されることを確認
- パフォーマンステスト（選択状態の変更が遅延しないか）

---

## 8. リスク評価

| リスク項目 | 発生確率 | 影響度 | 対策 |
|-----------|---------|--------|------|
| 既存機能の破壊 | 中 | 高 | 段階的な実装、テストの充実 |
| パフォーマンス劣化 | 低 | 中 | ベンチマーク実施 |
| 実装遅延 | 中 | 中 | 工数見積もりに余裕を持つ |
| ユーザー混乱 | 低 | 低 | ドキュメント整備 |

---

## 9. 結論

### 9.1 推奨事項

1. **Task 6.3では現状維持**
   - サブディレクトリの選択状態は無視
   - ルートレベルのみ選択可能

2. **次のマイルストーンでパスベース選択を実装**
   - ユーザーフィードバックを確認
   - 優先度を判断
   - 段階的な実装（Phase 1〜5）

3. **長期的にIDベース選択を検討**
   - パフォーマンスや機能拡張の必要性に応じて

### 9.2 次のアクション

- [ ] Task 6.3のリリース
- [ ] ユーザーフィードバックの収集
- [ ] パスベース選択の実装タスク作成（条件付き）
- [ ] 実装計画のレビュー

---

**作成日**: 2026-01-29
**作成者**: analysis-agent
**レビュー状況**: 未レビュー
**推奨度**: 中期的な実装を推奨（緊急度: 低）
